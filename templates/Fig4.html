<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fig. 4</title>
    <!--<script src="{{ url_for('static', filename='js/three.min.js') }}"></script>!-->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        body {
            position: relative;
            font-family: Arial, sans-serif;
        }

        /* Ensure the legend doesn't overlap with your top-left icon */
        .legend-container {
            position: absolute;
            top: 10px; /* Adjust as needed to avoid the icon */
            display: flex;
            width:100%;
            justify-content: center;
            display: flex;
            align-items: center;
            z-index: 10; /* Ensures it stays above other elements */
        }

        .gradient-scale {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right, white, gray, black);
            border: 1px solid #000;
            margin: 10px;
        }
        .legend-labels {
            position: absolute;
            top: 30px;
            justify-content: space-between;
        }

        .container {
            width: 33vw;
            height: 50vh;
            display: inline-block;
            border: 1px solid #ccc;
            margin: 5px;
            vertical-align: top; /* Ensures containers are aligned */
        }

        .label {
            text-align: center;
            margin-top: 10px;
            font-size: 1.5em;
            font-family: 'Times New Roman', Times, serif;
        }

        #containers {
            position: absolute;
            top: 70px;
            width: 100%;
            display: flex;
            justify-content: center; /* Evenly spaces the containers */
        }

        .container-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <header></header>
    <div id="containers">
        <div class="container-wrapper">
            <div id="container1" class="container"></div>
            <div class="label">(a)</div>
        </div>
        <div class="container-wrapper">
            <div id="container2" class="container"></div>
            <div class="label">(b)</div>
        </div>
    </div>
    <div class="legend-container">
        <!-- Gradient Scale --><span class="label">Visibility Index:</span>
        <div class="gradient-scale"></div>
        
        <!-- Legend Labels -->
        <div class="legend-labels">
            
            <span class="label">&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;&ensp;0</span>
            <span class="label">&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1</span>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import * as OBIM from './static/js/main.js'
        import * as OBIMcreate from './static/js/OBIM_create.js'
        const response = await fetch('./static/buildings_by_envelope.json');
        const data = await response.json();
        const containers = [
       document.getElementById('container1'),
       document.getElementById('container2')
        ];

        const renderers=[]
        const envs=[]
        containers.forEach((element)=>
        {
            const renderer = new THREE.WebGLRenderer();
             // Get the fixed container width and height
             renderer.setSize(element.clientWidth, element.clientHeight);
    
            
            element.appendChild(renderer.domElement);
            renderers.push(renderer)
        });
   
        envs.push(OBIMcreate.create_buildings_from_json(data,renderers[0],"Fig4a"))   
        envs.push(OBIMcreate.create_buildings_from_json(data,renderers[1],"Fig4b"))

        // Create a sphere and add it to the scene
        const sphereRadius = .15; // Radius of the sphere
        const sphereWidthSegments = 32; // Number of horizontal segments
        const sphereHeightSegments = 16; // Number of vertical segments
        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, sphereWidthSegments, sphereHeightSegments); // Create sphere geometry
        const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xff1111 }); // Material for the sphere
        
      
        
        const points=[[8,1,6],[3.5,8,6.5],[7.5,12,6.5]]
        for(let point of points)
        {
        const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial); // Create the sphere mesh
        sphereMesh.position.set(point[0],point[1],point[2]); // Set the position of the sphere (adjust as needed)
        envs[1].add(sphereMesh); // Assuming env1 is a THREE.Object3D or similar
        envs[0].add(sphereMesh.clone());

        const basePoint = new THREE.Vector3(point[0], point[1], point[2]);
        const arrowLength = 100;

        function visualizeRay(rayOrigin, rayDirection,color) {
            const endPoint = rayOrigin.clone().add(rayDirection);
            const geometry = new THREE.BufferGeometry().setFromPoints([rayOrigin, endPoint]);
            const material = new THREE.LineBasicMaterial({ color: color }); // Red color for visibility
            const line = new THREE.Line(geometry, material);
            envs[1].add(line); // Add the line to the scene
            envs[0].add(line.clone())
            }

        const radius = 20;       // Sphere radius
        const subdivisions = 20; // Number of subdivisions for the icosahedron (higher = more points)
        const geometry = new THREE.IcosahedronGeometry(radius, subdivisions);
        geometry.vertices.forEach(vertex => {
            const direction = new THREE.Vector3(vertex.x, vertex.y, vertex.z);  // Position at vertex
            let raycaster = new THREE.Raycaster(basePoint, direction);
            console.log("ray direction:",raycaster.ray.direction)
            const intersections = [];
            for (let child of envs[1].children) {
                        if (child instanceof OBIM.WALL || child instanceof OBIM.WINDOW || child instanceof OBIM.FLOOR) {
                            let boundingBox = new THREE.Box3().setFromObject(child);
                            if (child instanceof OBIM.WINDOW)
                            {boundingBox = new THREE.Box3().setFromObject(child.children[1]);}
                            
                            const intersection_Point = new THREE.Vector3();
                            if (raycaster.ray.intersectBox(boundingBox, intersection_Point)) {
                                console.log("Ray intersects bounding box");
                                const distance = basePoint.distanceTo(intersection_Point);
                                intersections.push({
                                    point: intersection_Point.clone(),
                                    distance: distance,
                                    object: child
                                });
                            }
                        }
                    }
            let rayColor = 0x00ff00; // Default green color
            intersections.sort((a, b) => a.distance - b.distance);
            let visualize=false;
            if (intersections.length >= 4) {
            if(intersections[0].object instanceof OBIM.WINDOW)
            {    if(intersections[2].object instanceof OBIM.WINDOW)
                    {visualize=true;}
                else if(intersections[3].object instanceof OBIM.WINDOW && intersections[3].object.wall==intersections[2].object)
                    {visualize=true;}
            }
            else if(intersections[1].object instanceof OBIM.WINDOW && intersections[1].object.wall==intersections[0].object)
            {
                if(intersections[2].object instanceof OBIM.WINDOW)
                    {visualize=true;}
                else if(intersections[3].object instanceof OBIM.WINDOW && intersections[3].object.wall==intersections[2].object)
                    {visualize=true;}
            }
                   // console.log(intersections[0])
                    //console.log(intersections[1])

            }

            if (visualize)
                    {
                        const distance=intersections[2].distance
                        const defaultNormal = new THREE.Vector3(0, 0, 1);
                        const wallNormal = defaultNormal.clone().applyEuler(intersections[2].object.rotation).normalize();
                        const dotProduct = wallNormal.dot(direction.clone().normalize());
                        // dot product is cosine
                        const angleRadians = Math.acos(dotProduct);
                        let angleDegrees = THREE.MathUtils.radToDeg(angleRadians);
                        if(angleDegrees>90)
                        {angleDegrees=180-angleDegrees}
                        //console.log("angle is:")
                        //console.log(angleDegrees)
                            // Fuzzy membership function for distance
                        function fuzzyDistanceWeight(d) {
                            if (d < 7) {
                                return 1; // High visibility
                            } else if (d >= 7 && d < 50) {
                                return (50 - d) / 43; // Linear decline
                            } else {
                                return 0; // No visibility
                            }
                        }

                        // Fuzzy membership function for angle
                        function fuzzyAngleWeight(theta) {
                            if (theta < 10) {
                                return 1; // High visibility
                            } else if (theta >= 10 && theta < 90) {
                                return (90 - theta) / 80; // Linear decline
                            } else {
                                return 0; // No visibility
                            }
                        }

                        // Calculate the weights
                        const distanceWeight = fuzzyDistanceWeight(distance);
                        const angleWeight = fuzzyAngleWeight(angleDegrees);

                        // Overall visibility weight
                        const visibilityWeight = distanceWeight * angleWeight;

                        //console.log("Distance Weight:", distanceWeight);
                        //console.log("Angle Weight:", angleWeight);
                        //console.log("Visibility Weight:", visibilityWeight);

                        const grayValue = Math.floor((1-visibilityWeight) * 255); // More visible -> lighter gray
                        const hexColor = (grayValue << 16) | (grayValue << 8) | grayValue;
                        visualizeRay(basePoint, direction, hexColor);
                        
                        //visibility_sum4+=visibilityWeight**10
                        
                    }
        });
        
    }

    </script>
</body>
</html>
